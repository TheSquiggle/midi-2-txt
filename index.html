<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate MIDI to Text Converter (Black MIDI Optimized)</title>
</head>
<body>

<h2>Upload a MIDI file</h2>
<input type="file" id="fileInput" accept=".mid">
<button onclick="convertMidi()">Convert to Text</button>
<br><br>
<progress id="progressBar" value="0" max="100" style="width:100%; display:none;"></progress>
<br><br>
<div id="noteDisplay"></div>
<div id="statusMessage" style="margin-top: 10px;"></div>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2"></script>
<script>
let midi;
let worker;

function convertMidi() {
    const fileInput = document.getElementById('fileInput');
    const progressBar = document.getElementById('progressBar');
    const statusMessage = document.getElementById('statusMessage');

    if (fileInput.files.length === 0) {
        alert('Please upload a MIDI file.');
        return;
    }

    progressBar.style.display = 'block';
    progressBar.value = 0;
    statusMessage.textContent = 'Loading MIDI file...';

    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function(event) {
        try {
            midi = new Midi(event.target.result);
        } catch (error) {
            alert('Failed to read MIDI file. Please check the file format.');
            progressBar.style.display = 'none';
            statusMessage.textContent = '';
            return;
        }

        // Log the entire MIDI object and its tracks for inspection
        console.log('MIDI object:', midi);
        console.log('Tracks:', midi.tracks);

        if (midi.tracks.length > 0) {
            let allNotes = [];

            // Check and log events for each track
            midi.tracks.forEach((track, trackIndex) => {
                console.log(`Track ${trackIndex} events:`, track.events);
                
                // Check if the track has events
                if (track.events && track.events.length > 0) {
                    track.events.forEach(event => {
                        // Only process noteOn and noteOff events
                        if (event.type === 'noteOn' || event.type === 'noteOff') {
                            allNotes.push({
                                pitch: event.noteNumber,  // MIDI note number (pitch)
                                length: event.duration ? event.duration.toFixed(3) : 'N/A',  // Event duration
                                time: event.time.toFixed(3),  // Event time
                                channel: event.channel || 'Unknown'  // Event channel
                            });
                        }
                    });
                } else {
                    console.log(`No events found in Track ${trackIndex}.`);
                }
            });

            console.log('Final notes with channels:', allNotes);

            allNotes.sort((a, b) => parseFloat(a.time) - parseFloat(b.time));

            let textContent = '';
            allNotes.forEach(note => {
                textContent += note.pitch + ':' + note.length + ':' + note.time + ':' + note.channel + '\n';
            });

            // Send back the results
            const blob = new Blob([textContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'midi_notes.txt';
            a.click();
            URL.revokeObjectURL(url);

            progressBar.value = 100;
            progressBar.style.display = 'none';
            statusMessage.textContent = 'Conversion complete. Downloading the file...';
        } else {
            alert('No tracks found in the MIDI file.');
            progressBar.style.display = 'none';
        }
    };

    reader.readAsArrayBuffer(file);
}
</script>

</body>
</html>
