<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI to Text Converter (Black MIDI Support)</title>
    <style>
        #noteDisplay {
            white-space: pre-wrap;
            border: 1px solid #ccc;
            padding: 10px;
            height: 200px;
            overflow-y: scroll;
        }
        canvas {
            border: 1px solid #000;
            width: 100%;
            height: 300px;
        }
    </style>
</head>
<body>

<h2>Upload a MIDI file</h2>
<input type="file" id="fileInput" accept=".mid">
<button id="convertButton">Convert to Text</button>
<br><br>
<progress id="progressBar" value="0" max="100" style="width:100%; display:none;"></progress>
<br><br>
<div>
    <h3>Track Selection</h3>
    <div id="trackSelection"></div>
</div>
<button onclick="playMidi()">Play MIDI</button>
<br><br>
<div id="noteDisplay"></div>
<canvas id="pianoRoll"></canvas>

<script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2"></script>
<script src="https://cdn.jsdelivr.net/npm/tone@14"></script>
<script>
let midi;
let synth;
let ctx = document.getElementById('pianoRoll').getContext('2d');
let maxTime = 0;
let worker;

function convertMidi() {
    const fileInput = document.getElementById('fileInput');
    const progressBar = document.getElementById('progressBar');
    const noteDisplay = document.getElementById('noteDisplay');
    const trackSelection = document.getElementById('trackSelection');

    if (fileInput.files.length === 0) {
        alert('Please upload a MIDI file.');
        return;
    }

    progressBar.style.display = 'block';
    progressBar.value = 0;

    const file = fileInput.files[0];
    const reader = new FileReader();

    reader.onload = function(event) {
        try {
            midi = new Midi(event.target.result);
        } catch (error) {
            alert('Failed to read MIDI file. Please check the file format.');
            progressBar.style.display = 'none';
            return;
        }

        noteDisplay.innerHTML = '';
        trackSelection.innerHTML = '';
        maxTime = 0;

        midi.tracks.forEach((track, index) => {
            const trackOption = document.createElement('input');
            trackOption.type = 'checkbox';
            trackOption.id = `track${index}`;
            trackOption.checked = true;

            const label = document.createElement('label');
            label.htmlFor = `track${index}`;
            label.textContent = ` Track ${index + 1} (${track.notes.length} notes)`;

            trackSelection.appendChild(trackOption);
            trackSelection.appendChild(label);
            trackSelection.appendChild(document.createElement('br'));
        });

        startWorker();
    };

    reader.readAsArrayBuffer(file);
}

function startWorker() {
    if (worker) worker.terminate();
    worker = new Worker(URL.createObjectURL(new Blob([`
        self.onmessage = function(event) {
            const midiData = event.data.midi;
            const selectedTracks = event.data.selectedTracks;

            let textContent = '';
            let totalNotes = 0;
            let processedNotes = 0;

            midiData.tracks.forEach((track, index) => {
                if (!selectedTracks.includes(index)) return;

                track.notes.forEach(note => {
                    const pitch = note.midi;
                    const length = note.duration.toFixed(3);
                    const time = note.time.toFixed(3);
                    textContent += \`\${pitch}:\${length}:\${time}\n\`;
                    totalNotes++;
                });
            });

            self.postMessage({ textContent, totalNotes });
        };
    `], { type: 'application/javascript' })));

    const selectedTracks = Array.from(document.querySelectorAll('#trackSelection input:checked'))
        .map(input => parseInt(input.id.replace('track', '')));

    worker.postMessage({ midi: midi.toJSON(), selectedTracks });

    worker.onmessage = function(event) {
        const { textContent, totalNotes } = event.data;
        downloadTextFile(textContent);
        progressBar.value = 100;
        progressBar.style.display = 'none';
        updatePianoRoll();
    };
}

function downloadTextFile(content) {
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'midi_notes.txt';
    a.click();

    URL.revokeObjectURL(url);
}

function updatePianoRoll() {
    if (!midi) return;

    const canvasHeight = 300;
    const canvasWidth = ctx.canvas.width;
    ctx.clearRect(0, 0, canvasWidth, canvasHeight);

    midi.tracks.forEach((track, index) => {
        if (!document.getElementById(`track${index}`).checked) return;

        track.notes.forEach(note => {
            const startX = (note.time / maxTime) * canvasWidth;
            const noteHeight = 10; // Height of each note on the roll
            const noteY = (128 - note.midi) * (canvasHeight / 128);
            const noteWidth = (note.duration / maxTime) * canvasWidth;

            ctx.fillStyle = 'rgba(0, 150, 255, 0.7)';
            ctx.fillRect(startX, noteY, noteWidth, noteHeight);
        });
    });
}

function playMidi() {
    if (!midi) {
        alert('Please upload a MIDI file first.');
        return;
    }

    if (synth) {
        synth.dispose();
    }

    synth = new Tone.PolySynth(Tone.Synth).toDestination();

    midi.tracks.forEach((track, index) => {
        if (!document.getElementById(`track${index}`).checked) return;

        track.notes.forEach(note => {
            synth.triggerAttackRelease(
                Tone.Frequency(note.midi, 'midi').toFrequency(),
                note.duration,
                Tone.now() + note.time
            );
        });
    });
}

// Ensure the script is fully loaded before attaching events
window.onload = function() {
    document.getElementById('convertButton').addEventListener('click', convertMidi);
};
</script>

</body>
</html>
